# Circular buffer for BFS
Clearâ€¿Pushâ€¿Popâ€¿Sizeâ†{
	nâ†10_000_000 â‹„ iâ€¿jâ†0â€¿0 â‹„ bufâ†nâ¥Š@
		Clearâ‡{ğ•¤ â‹„ jâ†©i}
	Pushâ‡{buf ğ•©Ë™âŒ¾(iâŠ¸âŠ‘)â†© â‹„ iâ†©n|i+1 â‹„ "Full buffer"!i>j â‹„ i-j}
	Popâ‡{i=j?ğ•©; râ†jâŠ‘buf â‹„ jâ†©n|j+1 â‹„ r}
	Sizeâ‡{ğ•¤â‹„n|i-j}
}

# Compute distances from the 'S'
Distsâ†{
	Dists map:
		Clear @
		hâ€¿wâ†â‰¢map
		iâ€¿jâ†âŠ‘(â¥Šğ•©='S')/âˆ¾(â†•w)â‹ˆËœÂ¨âš‡1â€¿0â†•h
		distâ†âˆÂ¨map â‹„ Push 0â€¿iâ€¿j
		Nextâ†{
			m ğ•Š dâ€¿iâ€¿j:
				âˆâ‰ iâ€¿jâŠ‘dist? Pop @;
			m ğ•Š dâ€¿iâ€¿j:
				dist dË™âŒ¾(iâ€¿jâŠ¸âŠ‘)â†©
				câ†{âˆ§Â´(0â€¿0â‰¤ğ•©)âˆ§(ğ•©<hâ€¿w)}Â¨âŠ¸/ (iâ€¿j)+âš‡1â€¿1âŸ¨Â¯1â€¿0,1â€¿0,0â€¿Â¯1,0â€¿1âŸ©
				câ†©c/Ëœ((âˆ=câŠ‘dist)âˆ§(câŠ‘m))
				PushÂ¨ ((d+1)âŠ¸âˆ¾)Â¨ c
				Pop @
		}
		(mapâ‰ '#') Next â€¢_while_ (@âŠ¸â‰¢) 0â€¿iâ€¿j
		dist
}

inputâ†>â€¢FLines âŠ‘âŠ"sample" â€¢args

# Part 1
Part1â†{max Part1 map: +Â´â¥Š {(0=2|max+ğ•©)âˆ§(ğ•©â‰¤max)}Â¨ Dists map}
â€¢Show 64 Part1 input

# Part 2
# This only works because there are no obstacles on the line/column with the S
# symbol in the real input (unlike in the sample).
Quadâ†{
	max Quad map:
		hâ€¿wâ†â‰¢map
		siâ€¿sjâ†âŠ‘(â¥Šmap='S')/âˆ¾(â†•w)â‹ˆËœÂ¨âš‡1â€¿0â†•h
		tileâ†'S'Ë™âŒ¾(0â€¿0âŠ¸âŠ‘) '.'Ë™âŒ¾âŠ‘Ë˜ {ğ”½âŒ¾â‰ ğ”½ ğ•©} (sjâŒ½â†•w)âŠ¸âŠË˜ (siâŒ½â†•h)âŠ¸âŠ map
		localâ†Â¯1â†“Â¯1â†“Ë˜ Dists (âˆ¾âŸœ'.'Ë˜ {ğ”½âŒ¾â‰ ğ”½ ğ•©} tile)
		evenoddâ†0â€¿1 =âš‡0â€¿âˆ 2|local
		nevenoddâ†(+Â´â¥Š)Â¨evenodd
		maxlocalâ†âŒˆÂ´(â‰ âŸœâˆ)âŠ¸/â¥Šlocal
		+Â´ {
			max â‰¥ maxlocal+hÃ—ğ•©?
				(ğ•©+1)Ã—(2|max+ğ•©)âŠ‘nevenodd;
			(ğ•©+1) Ã— +Â´â¥Š((2|max+ğ•©)âŠ‘evenodd)Ã—maxâ‰¥local+hÃ—ğ•©
		}Â¨ â†•âŒˆmaxÃ·h
}
Part2â†{max Part2 map: ((2|1+max)-4Ã—âŒˆ(max+1)Ã·2) + +Â´ (maxâŠ¸Quad)Â¨ âŠ¢â€¿âŒ½â€¿(âŒ½Ë˜)â€¿(âŒ½Ë˜âˆ˜âŒ½) {ğ• ğ•©}âš‡0â€¿âˆ input}
â€¢Show 26501365 Part2 input
